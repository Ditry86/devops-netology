# Домашнее задание к занятию "6.6. Troubleshooting"

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

### **Ответ:**

1. Операции для остановки процесса пользователя:
* Подключаемся к БД. Запрашиваем запущенные операции с временем исполнения более 3 мин. (180 секунд) 
```
use db <database>

db.currentOp(
   {
   true,
   
   "secs_running" : {$gt :180}
   }
)
```
* Прерываем необходимую операция по ее ID.

```
db.killop(<opid>)
```
2. Можно определить максимальное время работы для запроса <query>():
```
db.<query>().maxTimeMS(180000)
```

## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?

### **Ответ:**

При активной проверки истекших ключей Redis каждые 10 милисекунд производит выборку 20 (по-умолчанию) ключе со сроком действия. Получается, в секунду Redis проверяет 200 ключей. Ключи с истекшим сроком действия удаляются. В случае, когда ключей с истекшим сроком действия более 25% от числа выборки, Redis повторяет цикл до полного удаления таких ключей. При этом Redis может быть заблокирован до прекращения этих циклов.
При увеличении числа реплик в кластере может наступить момент, когда соотношение ключей с истекшим сроком действия к остальным ключам со сроком действия выборки может перевалить за 25%. Что приведет к временной блокировкам Redis до полного удаления просроченных ключей, либо снижения этого соотношения менее чем 25%.

 
## Задача 3

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?

### **Ответ:**

Данная ошибка появляется при увеличении времени выполнения запроса более чем время, указанное в параметре connect_timeout на самом сервере MySQL. Так же (судя по описанию фикса для данной проблемы (не бага)) данная ошибка может появлятся на клиенте, когда на сервере значение параметра connect_timeout меньше значения параметра innodb_lock_wait_timeout.
При росте количества запесей может наступить момент, когда выборка по запросу будет занимать больше времени чем время сеанса подключения клиента к БД connect_timeout.
Для решения проблемы можно умеличить значение параметра connect_timeout с дефолтного 10 сек. до, например, минуты и более (указывается в секундах). Для вычисления необходимого времени можно (или нужно :) использовать оператор EXPLAIN для запроса, вызывающего данную проблему.

## Задача 4


Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

Как бы вы решили данную проблему?

### **Ответ:**

Данная ошибка может появиться из-за переполнения памяти, и ядро системы сервера, а точнее защита памяти OOM-killer "убивает" процесс, занимающий больший объем памяти, в нашем случае сервер postgres - postmaster. После чего демон сервера postgres будет перезапущен при освобождении пямяти. Лучшим способой решить данную проблему - увеличить визическую память, особенно актуально для ВМ. Так же не совсем эффективным (в плане производительности СУБД) решением может послужить увеличение раздела подкачки swap.
При ограниченных ресурсах памяти для исключениея данной проблемы можно изменить поведение ядра ОС при резервировании памяти для запускаемого процесса с помощью параметра vm.overcommit_memory (изменить значение на 2), при этом система будет резервировать память для процесса не более чем указано в параметре overcommit_ratio, который в свою очередь является процентом от общего объема памяти системы. Данные параметры можно поменять с помощью утилиты sysctl, либо на постоянную прописать в файле /etc/sysctl.conf.
Остальные решения, включая отключение OOM-killer, для стабильной работы самой ОС сервера не являются безопасными.

---

### Как cдавать задание

Выполненное домашнее задание пришлите ссылкой на .md-файл в вашем репозитории.

---
